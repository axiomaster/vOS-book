# 从上电到引导扇区

## 上电

我们知道，现在使用的计算机都是*存储程序计算机（冯·诺依曼计算机）*。计算机运行时一边从内存中读取指令，一边执行指令。进一步，可能也知道对于8086 CPU，*段寄存器 CS*、*指令寄存器 IP*共同构成的地址```[CS:IP]```指向当前执行的指令。

但计算机上电开机之后，CS与IP中内容均为空，其它寄存器、内存的内容也为空。类似牛顿力学体系中的第一推动力一样，计算机上电后第一步该如何开始呢？牛顿给的答案是上帝提供了第一推动力。类似的，计算机启动第一步也只能通过体系外的某种方式解决。

上电后执行软件前只能靠硬件。CPU的硬件设计为上电后默认将**CS置为0xF000, IP置为0xFFF0**，即上电后默认执行的第一条指令位于```[CS:IP]=0xFFFF0```处的。而这个地址处存储的是BIOS。

### BIOS

我们都知道计算机启动后会运行BIOS(basic input output system)，进一步可能也知道BIOS存储在ROM中，当然也知道相对RAM，ROM掉电后信息不会丢失。计算机上电后，硬件将指令地址置为BIOS所在的```0xFFFF0```处，开始执行BIOS内容。

BIOS会先进行加电自检（POST, Power-On Self-Test），测试各项硬件是否正常等。

### 加电自检小插曲

    我前一阵（2019年底）组装了一台AMD的电脑（AMD, YES!!!）。不考虑打游戏，只用来沉迷于学习，所以预算里没有考虑显卡。等所有零件到了之后迫不及待装好之后上电，然后显示器黑屏，主板上有一个标有VGA的LED红灯常亮。

    想了一小会立即意识到，现在Intel的CPU基本都带了核显（大多数人觉得很鸡肋），但AMD的CPU并没有。BIOS加电自检挂这里过不去了。

    后来没办法，买了一张二手的GTX960作为亮机卡。

### BIOS中断

BIOS还会在内存中起始的4K处```0x00000-0x003FF```建立*中断向量表*，以及位于```0x0E05B-0x0FFFE```处对应的*中断服务程序*。

BIOS提供的中断服务可以查阅网上资料，参考资料中也提供了一份。我们会用到如下几个：

|中断号|描述|
|---|---|
|int 10h|显示服务|
|int 13h|低级磁盘服务|
|int 19h|加电自检后载入操作系统|

调用BIOS中断时，可能需要设置一些参数。比如```int 10h```中断用来在屏幕上显示信息，就需要指定显示的字符串内容，显示的颜色，位置等信息。中断信息如何设置，BIOS对此都有详细的说明。

## 加载bootsec

BIOS加电自检后使用```int 19h```中断将软盘中的第一个扇区（512 byte）中的内容复制到内存```0x7C00h```处，然后开始执行。在Linux中，第1个扇区的内容被称为bootsec。

对于OS来说，我们可以认为计算机加电后直到将bootsec中的内容载入内存并开始执行，这些都是自动完成的，我们只需要关注从bootsec代码开始执行之后的部分就可以了。

bootsec之后的事情我们也可以大致设想一下：依靠bootsec这512个字节的代码，我们会继续读取软盘上更多的代码，然后依赖读入的代码完成更多的工作，直至整个系统运行起来。

### 一个简单的bootsec样例

CPU硬件设计师，BIOS系统开发等费了九牛二虎之力，终于在上电之后把OS自身最开始的512个字节的bootsec给运行起来了。作为“全村的希望”，当然是希望我们再接再励把OS运行起来的。但这里，我们不管这么多，先用这宝贵的512个字节的代码量写一个hello world吧。

以下代码节选自《Orange's 一个操作系统的实现 第一章》

```asm
    org 07c00h         ; 告诉编译器程序加载到7c00处
    mov ax, cs
    mov ds, ax
    mov es, ax
    call DispStr       ; 调用显示字符串例程
    jmp $              ; 无限循环
DispStr:
    mov ax, BootMessage
    mov bp, ax         ; ES:BP = 串地址
    mov cx, 16         ; CX = 串长度
    mov ax, 01301h     ; AH = 13,  AL = 01h
    mov bx, 000ch      ; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮)
    mov dl, 0
    int 10h            ; 10h 号中断
    ret
BootMessage: db "Hello, OS world!"
times 510-($-$$) db 0 ; 填充剩下的空间，使生成的二进制代码恰好为512字节
dw 0xaa55             ; 结束标志
```

我们注意看第14行的```int 10h```，这就是上文提到的BIOS中断，这个中断是用来在屏幕显示信息的。前面一些内容，就是按照```int 10h```中断要求设置显示需要的一些参数。

#### 0xAA55

是不是将任意一张软盘插入计算机中，上电之后就会自动执行第1扇区的代码呢？其实并不是这样的。

软件中经常会约定使用一个魔数进行标识某个系统，比如在Java中，将文件中前4个字节固定为```CAFEBABE```用来标识这是一个class文件。同样，在BIOS中，约定只有当第一个扇区最后两个字节为```0xAA55```时才表示这是一个启动扇区。

#### 运行bootsec样例

- 编译代码

使用如下命令将以上汇编代码编译为二进制

```bash
nasm boot.asm -o boot.bin
```

- 将二进制写入软盘

可以先用bximage制作一个软盘镜像文件。

```bash
dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc
```

- 使用bochs运行bootsec

可以参考附录中的bochs中的使用方法。

## 参考资料

- [UEFI背后的历史](https://zhuanlan.zhihu.com/p/25281151)

- [BIOS中断调用](https://baike.baidu.com/item/BIOS%E4%B8%AD%E6%96%AD%E8%B0%83%E7%94%A8/22788153)
